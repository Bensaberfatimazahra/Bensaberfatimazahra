# -*- coding: utf-8 -*-
"""temperature prediction by machine learning

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KTCpK6PB0l62Af9V7WgajiQRba5ma_Wk

temperature prediction of Tlemcen, Algeria

**importer les bibliothèques**
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import warnings
from scipy import stats
import datetime
from sklearn.metrics import r2_score
import plotly.express as px
import plotly.graph_objects as go 
from ipywidgets import interact,widget
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import learning_curve
from sklearn.datasets import make_regression
from sklearn.linear_model import SGDRegressor
from sklearn.preprocessing import PolynomialFeatures
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import Ridge
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import validation_curve
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import Lasso
from sklearn.tree import DecisionTreeRegressor 
from sklearn.metrics import mean_squared_error
from sklearn.svm import NuSVR
from sklearn.svm import SVR ,SVC
import matplotlib.font_manager as font_manager
from xgboost import XGBRegressor
from sklearn.decomposition import PCA
from sklearn import preprocessing
from sklearn.preprocessing import LabelEncoder
from keras.models import Sequential
from keras.layers import Dense, Activation, Dropout
import datetime

"""**importation et nettoyage du dataset**"""

météo=pd.read_csv('/content/drive/MyDrive/TLEMCEN_ZENATA-hour- CSV 1.csv', sep=';') 
météo.rename(columns={'TEMPERATURE':'température'},inplace=True)
data=météo.copy()
data=pd.DataFrame(data)
data.rename(columns={'Unnamed: 3':'total_heurs','Mois':'month','jours':'day','heurs':'hour'},inplace=True)
data.loc[:,"year"]=np.array([2020]*len(data))
data= data.copy().drop('total_heurs', axis=1)
data= data.copy().drop('Unnamed: 4', axis=1)
data= data.copy().drop('Unnamed: 5', axis=1)
data= data.copy().drop('Unnamed: 6', axis=1)
data= data.copy().drop('Unnamed: 7', axis=1)
data= data.copy().drop('Unnamed: 8', axis=1)
data['date'] = pd.to_datetime(data[['month','day','year','hour']], format='%m/%d/%Y/%H',errors = 'coerce')
data

""" ****Division des saisons ****"""

ses1=[]
ses2=[]
ses3=[]
ses4=[]
ses5=[]
if data['date'].any:
  ses1.append(data['date'].iloc[:1898])
  ses10=[elem.replace(data['date'].values,"L'hiver") for elem in ses1]
  
  ses100=pd.DataFrame(ses10).transpose()
#print(ses100)
if data['date'].any:
  ses2.append(data['date'].iloc[1898:4106])
  ses20=[elem.replace(data['date'].values,"Le printemps") for elem in ses2]
  ses200=pd.DataFrame(ses20).transpose()
#print(ses200)

if data['date'].any:
  ses3.append(data['date'].iloc[4106:6314])
  ses30=[elem.replace(data['date'].values,"L'été") for elem in ses3]
  ses300=pd.DataFrame(ses30).transpose()
#print(ses3)
if data['date'].any:
  ses4.append(data['date'].iloc[6314:8498])
  ses40=[elem.replace(data['date'].values,"L'automne") for elem in ses4]
  ses400=pd.DataFrame(ses40).transpose()
if data['date'].any:
  ses5.append(data['date'].iloc[8498:])
  ses50=[elem.replace(data['date'].values,"L'hiver") for elem in ses5]
  ses500=pd.DataFrame(ses50).transpose()  
#print(ses4)
SAISON=pd.concat([ses100,ses200,ses300,ses400,ses500])
SAISON
data['SAISON']=pd.concat([ses100,ses200,ses300,ses400,ses500])

"""**Visualisation du dataset**"""

fig = px.line(data, x='date', y='température', color='SAISON',labels={
"date": "date", "température": "Température (°C)","SAISON": "Saisons"},range_y=[0,45],animation_frame="hour",
title="Le changement de température par saison ")
fig.show()

fig = px.area(data, x='month', y='température', color='SAISON',labels={
"month": "Mois", "température": "Température (°C)","SAISON": "Saisons"},range_y=[0,45],animation_frame="day",
title="Le changement de température par saison ")
fig.show()

fig = px.area(data, x='date', y='température', color='SAISON',labels={
"date": "date", "température": "Température (°C)","SAISON": "Saisons"},animation_frame="hour",range_y=[0,45],
title="Le changement de température par saison  ")
fig.show()
fig.write_html("fati.mp4")

fig = px.line(data, x='day', y='température', color='SAISON',labels={
"date": "date", "température": "Température (°C)","SAISON": "Saisons"},animation_frame="hour",range_y=[0,45],
title="Le changement de température par saison  ")
fig.show()

fig = px.area(data, x='day', y='température', color='month',animation_frame="month",labels={
"day": "jours", "température": "Température (°C)","month": "Mois"},
        range_y=[0,45],
       
title=" changement de température  des jours des saison on fonction  de mois ")
fig.show()

"""**Préparation pour l'apprentissage**"""

data["hour"] = [x.hour for x in data["date"]]
# Creating the cyclical daily feature 
data["day_cos"] = [np.cos(x * (2 * np.pi / 24)) for x in data["hour"]]
data["day_sin"] = [np.sin(x * (2 * np.pi / 24)) for x in data["hour"]]
data=data.copy()
data['SAISON']

data["timestamp"] = [x.timestamp() for x in data["date"]]
# Seconds in day 
s = 24 * 60 * 60
# Seconds in year 
year = (365.25) * s
data["month_cos"] = [np.cos((x) * (2 * np.pi / year)) for x in data["timestamp"]]
data["month_sin"] = [np.sin((x) * (2 * np.pi / year)) for x in data["timestamp"]]
data

features_final = [ 'température','day_cos','day_sin','month','day','hour','timestamp','month_cos','month_sin']
test_share = 0.2

#  les colonnes nécessaires 
ts = data[features_final]
nrows = ts.shape[0]
# Division en ensembles de train et de test 
train = ts[0:int (nrows * (1- test_share))]
test = ts[int (nrows * (1 - test_share)):]
# Standariser les données
train_mean = train.mean()
train_std = train.std()
train = (train - train_mean)/ train_std
test = (test - train_mean) / train_std
 # Création du dataset final
ts_s = pd.concat([train, test])
sns.pairplot(ts_s)

"""**les features et la target**"""

x=['day_cos','day_sin','month','day','hour','timestamp','month_cos','month_sin']
X=ts_s[x]
Y=data['température']

X_train, X_test, Y_train, Y_test = train_test_split(X ,Y, test_size = 0.2, random_state=5)

models={'SVR':SVR(),'XGBRegressor':XGBRegressor(objective='reg:linear', verbosity = 0, colsample_bytree=0.3, learning_rate=0.1,
                    max_depth=400, alpha=10, n_estimators=400),
        'randomforest':RandomForestRegressor(n_estimators=400, max_depth=400, random_state=0),
        'arbredeclassification':DecisionTreeRegressor(criterion='mse',random_state=42,splitter='best') ,
        'regression_linéaire':LinearRegression(),
        'lasso':Lasso(alpha=1.0),
        'ridge':Ridge(alpha=1.0),
        'nusvr':NuSVR( gamma = 'auto', C = 1.0, nu = 0.1) }

def train_test(models,X_train ,Y_train ,X_test ,Y_test ):
  fig,ax=plt.subplots()
  
  print('***LA PERFORMANCE DU MODEL DE MACHINE LEARNING  POUR LA PREDICTION  DE TEMPERATURE***')
  print('=========================================================================')
  for (name,model) in models.items():
    print('*',name,':')
    print('------------')
    #entrainé les modèles
    start1 = datetime.datetime.now() 
    model.fit(X_train ,Y_train)
    end1 = datetime.datetime.now()
    print("Le temps d'apprentissage: ", end1-start1)
    #faire la prédiction
    start = datetime.datetime.now()
    predictions=model.predict(X_test)
    end = datetime.datetime.now()
    print("Le temps de la prédiction: ", end-start)
    #les scores du modèles 
    score=model.score(X_train, Y_train)*100
    print ('=> score =',model.score(X_train, Y_train)*100,'%')
    if model.score(X_train, Y_train)*100< 50:
      print("=> ce model n'est pas performant :(")
    elif model.score(X_train, Y_train)*100>= 50 and  model.score(X_train, Y_train)*100<= 75 :
      print("=> ce model est bon :) ")
    elif model.score(X_train, Y_train)*100>= 80:
      print("=> ce model est exellent :) ")
    #l'erreur quadrature moyenne
    rmse = (np.sqrt(mean_squared_error(Y_test, predictions)))
    print('=> Lerreur quadratique moyenne est =',rmse )
    #l'erreur standard
    mse=mean_squared_error(Y_test,predictions)
    print("=>L'erreur standard est=",mse)
    #le coefficients de détermination
    print('R2\t'+str(r2_score(Y_test, predictions))+'\n')
    plt.plot(predictions,Y_test,'ro',alpha=0.5,label='prédictive model')
    plt.plot(Y_test,Y_test,'--')
    plt.title(f'modèle :{name}', backgroundcolor='y') 
    plt.xlabel('temperature')
    plt.ylabel('température prédict')
    ax.text(0.8,0.1,'erreur:{:.2f}\n$R^2$:{:.2f}%'.format(rmse,score),transform=ax.transAxes,bbox={'facecolor':'w','edgecolor':'k'})
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)
    
    plt.show()
    print('***************************************************************************************************************************')
   
    
train_test(models,X_train ,Y_train ,X_test ,Y_test )

title_font = {'fontname':'Arial', 'size':'26', 'color':'black', 'weight':'normal',
              'verticalalignment':'bottom'} 
axis_font = {'fontname':'Arial', 'size':'24'}

def bar_erreur(models,X_train ,Y_train ,X_test ,Y_test ):
  fig = plt.figure()
  plt.figure(figsize=(25,15))
  fig,ax = plt.subplots()
  for (name,model) in models.items():
    model.fit(X_train ,Y_train)
    predictions=model.predict(X_test)
    rmse = (np.sqrt(mean_squared_error(Y_test, predictions)))
    ax.bar(name,rmse,label=f'{name}')  
  plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)
  plt.xlabel('Modèles',**axis_font)
  plt.ylabel('Erreur quadrature',**axis_font)
  plt.xticks(rotation='vertical')
  plt.yticks(np.arange(0,4,0.5))
  plt.title("Comparaison  d'erreur pour chaque modèle", **title_font, backgroundcolor='y')
  plt.show()
  fig.savefig('modèle.png', dpi=fig.dpi)
bar_erreur(models,X_train ,Y_train ,X_test ,Y_test )



def bar_score(models,X_train ,Y_train ,X_test ,Y_test ):
  plt.figure(figsize=(25,15))
  fig,ax = plt.subplots()
  for (name,model) in models.items():
    model.fit(X_train ,Y_train)
    predictions=model.predict(X_test)
    score =model.score(X_train, Y_train)*100
    rmse = (np.sqrt(mean_squared_error(Y_test, predictions)))
    
    ax.bar(name,score,label=f'{name}')  
  plt.legend(bbox_to_anchor=(1.05, 1), loc='best')
  plt.xlabel('Modèles',**axis_font)
  plt.ylabel('Score',**axis_font)
  plt.xticks(rotation='vertical')
  plt.yticks(np.arange(0,105,5))
  plt.title('Comparaison  de score pour chaque modèle', **title_font, backgroundcolor='y')
  plt.show()
  fig.savefig('score.png', dpi=fig.dpi)
bar_score(models,X_train ,Y_train ,X_test ,Y_test )



model=DecisionTreeRegressor(criterion='mse',random_state=42,splitter='best')

model.fit(X_train ,Y_train)

score=model.score(X_train, Y_train)*100
print ('=> score =',score,'%')
if model.score(X_train, Y_train)*100< 50:
  print("=> ce model n'est pas performant :(")
elif model.score(X_train, Y_train)*100>= 50 and  model.score(X_train, Y_train)*100<= 75 :
  print("=> ce model est bon :) ")
elif model.score(X_train, Y_train)*100>= 80:
  print("=> ce model est exellent :) ")



predictions=model.predict(X_test)

pred=pd.DataFrame(predictions,columns=['prediction'])

print('R2\t'+str(r2_score(Y_test, predictions))+'\n')
plt.plot(Y_test,predictions,'ro', alpha=0.5)
plt.plot(Y_test,Y_test,'--')
plt.title(' prédiction de température', backgroundcolor='y') 
plt.xlabel('température')
plt.ylabel('température prédict')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)
plt.show()

predictions=model.predict(X_test)
y =Y_test
# Creating the frame to store both predictions
days = data['date'].values[:len(y)]
heurs=data['hour'].values[:len(y)]
frame = pd.concat([pd.DataFrame({'date': days, 'Température (°C)': y, 'type': 'original','heurs':heurs}),
                       pd.DataFrame({'date': days, 'Température (°C)': predictions, 'type': 'prédit','heurs':heurs})
                       ])
fig=px.line(frame,x='date',y='Température (°C)',color='type',category_orders={'type':['original','prédit']}
            ,color_discrete_map={'original':'royalblue','prédit':'orange'},animation_frame='heurs',title="Comparaison entre la température réelle et la température prédit")
fig.show()

#comparaison des modèles  température
fig,ax = plt.subplots()
model = LinearRegression() 
start1 = datetime.datetime.now()
model.fit(X_train, Y_train)
end1 = datetime.datetime.now()
time1=end1-start1
print("temps d'apprentissage=",time1)
start = datetime.datetime.now()
predictions=model.predict(X_test)
end = datetime.datetime.now()
time=end-start
score =model.score(X_train, Y_train)*100
R2=(r2_score(Y_test, predictions))
rmse = (np.sqrt(mean_squared_error(Y_test, predictions)))
plt.plot(Y_test,predictions,'ro',label='prédictive model')
plt.plot(Y_test,Y_test,'--')
plt.title('Regression linéaire', backgroundcolor='y')
plt.xlabel('température')
plt.ylabel('température prédit')
ax.text(0.9,0.2,'erreur:{:.2f}\n$score$:{:.2f}%\n$R^2$:{:.4f}'.format(rmse,score,R2),transform=ax.transAxes,bbox={'facecolor':'w','edgecolor':'k'})
plt.savefig('MODEL_linéaire.png')
plt.show()

fig,ax = plt.subplots()
model = SVR(C=100) 
start1 = datetime.datetime.now()
model.fit(X_train, Y_train)
end1 = datetime.datetime.now()
time1=end1-start1
print("temps d'apprentissage=",time1)
start = datetime.datetime.now()
predictions2=model.predict(X_test)
end = datetime.datetime.now()
time=end-start
score =model.score(X_train, Y_train)*100
R2=(r2_score(Y_test, predictions2))
rmse = (np.sqrt(mean_squared_error(Y_test, predictions2)))
plt.plot(Y_test,predictions2,'ro',label='prédictive model')
plt.plot(Y_test,Y_test,'--')
plt.title('SVM (SVR)', backgroundcolor='y')
plt.xlabel('température')
plt.ylabel('température prédit')
ax.text(0.9,0.2,'erreur:{:.2f}\n$score$:{:.2f}%\n$R^2$:{:.4f}'.format(rmse,score,R2),transform=ax.transAxes,bbox={'facecolor':'w','edgecolor':'k'})
plt.savefig('MODEL_SVR.png')
plt.show()

fig,ax = plt.subplots()
model = Lasso(alpha=1.0) 
start1 = datetime.datetime.now()
model.fit(X_train, Y_train)
end1 = datetime.datetime.now()
time1=end1-start1
print("temps d'apprentissage=",time1)
start = datetime.datetime.now()
predictions3=model.predict(X_test)
end = datetime.datetime.now()
time=end-start
score =model.score(X_train, Y_train)*100
R2=(r2_score(Y_test, predictions3))
rmse = (np.sqrt(mean_squared_error(Y_test, predictions3)))
plt.plot(Y_test,predictions3,'ro',label='prédictive model')
plt.plot(Y_test,Y_test,'--')
plt.title('REGRESSION DE LASSO', backgroundcolor='y')
plt.xlabel('température')
plt.ylabel('température prédit')
ax.text(0.9,0.2,'erreur:{:.2f}\n$score$:{:.2f}%\n$R^2$:{:.4f}'.format(rmse,score,R2),transform=ax.transAxes,bbox={'facecolor':'w','edgecolor':'k'})
plt.savefig('MODEL_LASSO.png')
plt.show()

fig,ax = plt.subplots()
model = Ridge(alpha=1.0) 
start1 = datetime.datetime.now()
model.fit(X_train, Y_train)
end1 = datetime.datetime.now()
time1=end1-start1
print("temps d'apprentissage=",time1)
start = datetime.datetime.now()
predictions4=model.predict(X_test)
end = datetime.datetime.now()
time=end-start
score =model.score(X_train, Y_train)*100
R2=(r2_score(Y_test, predictions4))
rmse = (np.sqrt(mean_squared_error(Y_test, predictions4)))
plt.plot(Y_test,predictions4,'ro',label='prédictive model')
plt.plot(Y_test,Y_test,'--')
plt.title('REGRESSION DE Ridge', backgroundcolor='y')
plt.xlabel('température')
plt.ylabel('température prédit')
ax.text(0.9,0.2,'erreur:{:.2f}\n$score$:{:.2f}%\n$R^2$:{:.4f}'.format(rmse,score,R2),transform=ax.transAxes,bbox={'facecolor':'w','edgecolor':'k'})
plt.savefig('MODEL_Ridge.png')
plt.show()

fig,ax = plt.subplots()
model= DecisionTreeRegressor(random_state = 0) 
start1 = datetime.datetime.now()
model.fit(X_train, Y_train)
end1 = datetime.datetime.now()
time1=end1-start1
print("temps d'apprentissage=",time1)
start = datetime.datetime.now()
predictions5=model.predict(X_test)
end = datetime.datetime.now()
time=end-start
R2=(r2_score(Y_test, predictions5))
score =model.score(X_train, Y_train)*100
rmse = (np.sqrt(mean_squared_error(Y_test, predictions5)))
plt.plot(Y_test,predictions5,'ro',label='prédictive model')
plt.plot(Y_test,Y_test,'--')
plt.title('Decision Tree Regression', backgroundcolor='y') 
plt.xlabel('température')
plt.ylabel('température prédit')
ax.text(0.9,0.2,'erreur:{:.2f}\n$score$:{:.2f}%\n$R^2$:{:.4f}'.format(rmse,score,R2),transform=ax.transAxes,bbox={'facecolor':'w','edgecolor':'k'})
plt.savefig('MODEL_Decision_Tree_Regression.png')
plt.show()

fig,ax = plt.subplots()
model= NuSVR( gamma = 'auto', C = 1.0, nu = 0.1)
start1 = datetime.datetime.now()
model.fit(X_train, Y_train)
end1 = datetime.datetime.now()
time1=end1-start1
print("temps d'apprentissage=",time1)
start = datetime.datetime.now()
predictions6=model.predict(X_test)
end = datetime.datetime.now()
time=end-start
R2=(r2_score(Y_test, predictions6))
plt.plot(Y_test,predictions6,'ro',label='prédictive model')
plt.plot(Y_test,Y_test,'--') 
plt.title('NuSVR', backgroundcolor='y') 
plt.xlabel('température')
plt.ylabel('température prédit')
score =model.score(X_train, Y_train)*100
rmse = (np.sqrt(mean_squared_error(Y_test, predictions6)))
ax.text(0.9,0.2,'erreur:{:.2f}\n$score$:{:.2f}%\n$R^2$:{:.4f}'.format(rmse,score,R2),transform=ax.transAxes,bbox={'facecolor':'w','edgecolor':'k'})
plt.savefig('MODEL_NuSVR.png')
plt.show()

fig,ax = plt.subplots()
model=RandomForestRegressor(n_estimators = 1000, random_state = 42)
start1 = datetime.datetime.now()
model.fit(X_train, Y_train)
end1 = datetime.datetime.now()
time1=end1-start1
print("temps d'apprentissage=",time1)
start = datetime.datetime.now()
predictions7=model.predict(X_test)
end = datetime.datetime.now()
time=end-start
score =model.score(X_train, Y_train)*100
rmse = (np.sqrt(mean_squared_error(Y_test, predictions7)))
R2=(r2_score(Y_test, predictions7))
plt.plot(Y_test,predictions7,'ro',label='prédictive model')
plt.plot(Y_test,Y_test,'--')
plt.title('RANDOM FOREST', backgroundcolor='y') 
plt.xlabel('température')
plt.ylabel('température prédit')
ax.text(0.9,0.2,'erreur:{:.2f}\n$score$:{:.2f}%\n$R^2$:{:.4f}'.format(rmse,score,R2),transform=ax.transAxes,bbox={'facecolor':'w','edgecolor':'k'})
plt.savefig('MODEL_RandomForestRegressor.png')
plt.show()

fig,ax = plt.subplots()
model=XGBRegressor(objective='reg:linear', verbosity = 0, colsample_bytree=0.3, learning_rate=0.1,
                    max_depth=400, alpha=10, n_estimators=400)
start1 = datetime.datetime.now()
model.fit(X_train, Y_train)
end1 = datetime.datetime.now()
time1=end1-start1
print("temps d'apprentissage=",time1)
start = datetime.datetime.now()
predictions8=model.predict(X_test)
end = datetime.datetime.now()
time=end-start
R2=(r2_score(Y_test, predictions8))
score =model.score(X_train, Y_train)*100
rmse = (np.sqrt(mean_squared_error(Y_test, predictions8)))
plt.plot(Y_test,predictions8,'ro',label='prédictive model')
plt.plot(Y_test,Y_test,'--')
plt.title('XGBRegressor', backgroundcolor='y') 
plt.xlabel('température')
plt.ylabel('température prédit')
ax.text(0.9,0.2,'erreur:{:.2f}\n$score$:{:.2f}%\n$R^2$:{:.4f}'.format(rmse,score,R2),transform=ax.transAxes,bbox={'facecolor':'w','edgecolor':'k'})
plt.savefig('MODEL_XGBRegressor.png')
plt.show()